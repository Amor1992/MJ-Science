<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸš€ å¤ªé˜³ç³»æ¢é™© - PhETé£æ ¼äº’åŠ¨æ¨¡æ‹Ÿ</title>
    <style>
        /* ==================== CSSæ ·å¼åŒºåŸŸ ==================== */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #0a0a2e 0%, #1a1a4e 50%, #2a2a6e 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* æ˜Ÿæ˜ŸèƒŒæ™¯ */
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
        
        /* åŠ¨æ€æç¤ºæ¡† */
        #hint {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            pointer-events: none;
            z-index: 100;
            border: 2px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(5px);
            max-width: 90vw;
            text-align: center;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        /* æ§åˆ¶é¢æ¿ */
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }
        
        .control-btn {
            padding: 8px 16px;
            background: rgba(26, 84, 144, 0.8);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: rgba(26, 84, 144, 1);
            transform: scale(1.05);
        }
        
        .control-btn.active {
            background: rgba(76, 175, 80, 0.8);
            border-color: rgba(76, 175, 80, 1);
        }
        
        /* ä¿¡æ¯é¢æ¿ */
        #info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            max-width: 300px;
            display: none;
            z-index: 100;
            border: 2px solid rgba(255, 215, 0, 0.5);
            backdrop-filter: blur(10px);
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        #info-panel h3 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 18px;
        }
        
        #info-panel p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        #info-panel .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            opacity: 0.7;
        }
        
        #info-panel .close-btn:hover {
            opacity: 1;
        }
        
        /* é€Ÿåº¦æŒ‡ç¤ºå™¨ */
        #speed-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* å®Œæˆå¥–åŠ±å±‚ */
        #reward-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
        }
        
        #medal {
            font-size: 120px;
            animation: medal-pop 0.6s ease-out, medal-glow 2s infinite;
        }
        
        @keyframes medal-pop {
            0% { transform: scale(0) rotate(-180deg); }
            80% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        @keyframes medal-glow {
            0%, 100% { filter: drop-shadow(0 0 10px #ffd700); }
            50% { filter: drop-shadow(0 0 30px #ffd700); }
        }
        
        #reward-text {
            color: #ffd700;
            font-size: 36px;
            margin-top: 20px;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            animation: text-fade 1s ease-out 0.3s both;
        }
        
        @keyframes text-fade {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #reward-stats {
            color: #fff;
            font-size: 18px;
            margin-top: 15px;
            text-align: center;
            animation: text-fade 1s ease-out 0.6s both;
        }
        
        #rocket {
            position: absolute;
            font-size: 100px;
            opacity: 0;
        }
        
        #restart-btn {
            margin-top: 30px;
            padding: 15px 50px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.5);
            transition: all 0.3s;
            animation: text-fade 1s ease-out 0.9s both;
        }
        
        #restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(102, 126, 234, 0.7);
        }
        
        /* åŠ è½½åŠ¨ç”» */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 300;
        }
        
        #loading .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        #loading p {
            color: white;
            margin-top: 20px;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loading">
        <div class="spinner"></div>
        <p>ğŸš€ æ­£åœ¨å¯åŠ¨å¤ªç©ºæ¢é™©...</p>
    </div>
    
    <!-- æ¸¸æˆå®¹å™¨ -->
    <div id="game-container">
        <!-- åŠ¨æ€æç¤º -->
        <div id="hint">ğŸŒŸ æ‹–æ‹½è¡Œæ˜Ÿåˆ°æ­£ç¡®çš„è½¨é“ä¸Šå§ï¼</div>
        
        <!-- æ§åˆ¶æŒ‰é’® -->
        <div id="controls">
            <button class="control-btn" onclick="game.toggleExperimentMode()">ğŸ”¬ å®éªŒæ¨¡å¼</button>
            <button class="control-btn" onclick="game.toggleSlowMotion()">ğŸ¢ æ…¢åŠ¨ä½œ</button>
            <button class="control-btn" onclick="game.resetOrbits()">ğŸ”„ é‡ç½®è½¨é“</button>
        </div>
        
        <!-- æ¸¸æˆç”»å¸ƒ -->
        <canvas id="game-canvas"></canvas>
        
        <!-- ç«ç®­åŠ¨ç”» -->
        <div id="rocket">ğŸš€</div>
        
        <!-- é€Ÿåº¦æŒ‡ç¤ºå™¨ -->
        <div id="speed-indicator">âš¡ é€Ÿåº¦: 1.0x</div>
    </div>
    
    <!-- ä¿¡æ¯é¢æ¿ -->
    <div id="info-panel">
        <button class="close-btn" onclick="game.closeInfoPanel()">Ã—</button>
        <h3 id="info-title">è¡Œæ˜Ÿåç§°</h3>
        <p id="info-distance"></p>
        <p id="info-temp"></p>
        <p id="info-fun"></p>
    </div>
    
    <!-- å®Œæˆå¥–åŠ±å±‚ -->
    <div id="reward-overlay">
        <div id="medal">ğŸ…</div>
        <div id="reward-text">å¤ªç©ºæ¢é™©å®¶</div>
        <div id="reward-stats">
            å®Œæˆæ—¶é—´: <span id="completion-time">0</span> ç§’<br>
            å°è¯•æ¬¡æ•°: <span id="attempt-count">0</span> æ¬¡
        </div>
        <button id="restart-btn" onclick="game.restart()">å†ç©ä¸€æ¬¡</button>
    </div>

    <script>
        // ==================== æ•°æ®æ¨¡å‹ ====================
        
        const PLANET_DATA = [
            { 
                name: 'æ°´æ˜Ÿ', 
                color: '#b5b5b5', 
                radius: 28,
                orbitIndex: 0,
                emoji: 'ğŸª¨',
                distance: 'è·å¤ªé˜³æœ€è¿‘çš„è¡Œæ˜Ÿ',
                temp: 'è¡¨é¢æ¸©åº¦ï¼š-180Â°C ~ 430Â°C',
                fun: 'ğŸ’¡ æ°´æ˜Ÿä¸€å¹´åªæœ‰88å¤©ï¼',
                mass: 0.055,
                size: 'ç›´å¾„ 4,879 km'
            },
            { 
                name: 'é‡‘æ˜Ÿ', 
                color: '#e6c87a', 
                radius: 40,
                orbitIndex: 1,
                emoji: 'ğŸŒ•',
                distance: 'å¤ªé˜³ç³»ä¸­æœ€çƒ­çš„è¡Œæ˜Ÿ',
                temp: 'è¡¨é¢æ¸©åº¦ï¼š462Â°Cï¼ˆæ¯”æ°´æ˜Ÿè¿˜çƒ­ï¼ï¼‰',
                fun: 'ğŸ’¡ é‡‘æ˜Ÿè‡ªè½¬æ–¹å‘ä¸å…¶ä»–è¡Œæ˜Ÿç›¸å',
                mass: 0.815,
                size: 'ç›´å¾„ 12,104 km'
            },
            { 
                name: 'åœ°çƒ', 
                color: '#6b93d6', 
                radius: 42,
                orbitIndex: 2,
                emoji: 'ğŸŒ',
                distance: 'å”¯ä¸€å·²çŸ¥å­˜åœ¨ç”Ÿå‘½çš„è¡Œæ˜Ÿ',
                temp: 'å¹³å‡æ¸©åº¦ï¼š15Â°C',
                fun: 'ğŸ’¡ åœ°çƒæœ‰1é¢—å¤©ç„¶å«æ˜Ÿï¼šæœˆçƒ',
                mass: 1.0,
                size: 'ç›´å¾„ 12,742 km'
            },
            { 
                name: 'ç«æ˜Ÿ', 
                color: '#c1440e', 
                radius: 34,
                orbitIndex: 3,
                emoji: 'ğŸ”´',
                distance: 'è¢«ç§°ä¸º"çº¢è‰²æ˜Ÿçƒ"',
                temp: 'å¹³å‡æ¸©åº¦ï¼š-63Â°C',
                fun: 'ğŸ’¡ ç«æ˜Ÿä¸Šæœ‰å¤ªé˜³ç³»æœ€é«˜çš„å±±ï¼šå¥¥æ—å¸•æ–¯å±±',
                mass: 0.107,
                size: 'ç›´å¾„ 6,779 km'
            },
            { 
                name: 'æœ¨æ˜Ÿ', 
                color: '#d8ca9d', 
                radius: 60,
                orbitIndex: 4,
                emoji: 'ğŸŸ¤',
                distance: 'å¤ªé˜³ç³»æœ€å¤§çš„è¡Œæ˜Ÿ',
                temp: 'äº‘é¡¶æ¸©åº¦ï¼š-145Â°C',
                fun: 'ğŸ’¡ æœ¨æ˜Ÿæœ‰79é¢—å·²çŸ¥å«æ˜Ÿï¼',
                mass: 317.8,
                size: 'ç›´å¾„ 139,820 km'
            }
        ];
        
        const ORBIT_CONFIG = {
            count: 5,
            baseRadius: 70,
            spacing: 55,
            centerX: 0,
            centerY: 0
        };
        
        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        
        const GameState = {
            planets: [],
            draggingPlanet: null,
            completedOrbits: [],
            isComplete: false,
            
            // æ¸¸æˆç»Ÿè®¡
            startTime: null,
            attempts: 0,
            currentAttempt: 0,
            
            // æ¨¡å¼è®¾ç½®
            experimentMode: false,
            slowMotion: false,
            speedMultiplier: 1.0,
            
            // ç”»å¸ƒ
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            
            // å¸ƒå±€
            planetAreaY: 0,
            planetSpacing: 0
        };
        
        // ==================== åŠ¨æ€æç¤ºç³»ç»Ÿ ====================
        
        const HintSystem = {
            state: 'welcome',
            hints: {
                welcome: 'ğŸŒŸ æ‹–æ‹½è¡Œæ˜Ÿåˆ°æ­£ç¡®çš„è½¨é“ä¸Šå§ï¼',
                dragging: 'ğŸ‘† æ‰¾åˆ°å¯¹åº”è·ç¦»çš„è½¨é“ï¼Œè¡Œæ˜Ÿä¼šè‡ªåŠ¨å¸é™„',
                near_orbit: 'âœ¨ å¾ˆæ¥è¿‘äº†ï¼æ¾å¼€è¯•è¯•çœ‹',
                wrong_orbit: 'ğŸ¤” è¿™ä¸ªè½¨é“å¥½åƒä¸å¯¹ï¼Œå†è¯•è¯•åˆ«çš„ï¼Ÿ',
                snapped: 'âœ… å¤ªæ£’äº†ï¼å·²æ­£ç¡®æ”¾ç½®',
                complete: 'ğŸ‰ æ‰€æœ‰è¡Œæ˜Ÿéƒ½å½’ä½äº†ï¼å¤ªé˜³ç³»ç»„è£…å®Œæˆï¼',
                experiment: 'ğŸ”¬ å®éªŒæ¨¡å¼ï¼šéšæ„æ”¾ç½®è¡Œæ˜Ÿï¼Œè§‚å¯Ÿä¸åŒè½¨é“çš„å…¬è½¬é€Ÿåº¦ï¼'
            },
            
            init() {
                this.state = 'welcome';
                this.renderHint();
            },
            
            setState(state) {
                this.state = state;
                this.renderHint();
            },
            
            renderHint() {
                const hintEl = document.getElementById('hint');
                hintEl.textContent = this.hints[this.state];
                hintEl.style.animation = 'none';
                hintEl.offsetHeight;
                hintEl.style.animation = 'fadeIn 0.3s ease-in';
            }
        };
        
        // ==================== ä¿¡æ¯é¢æ¿ç³»ç»Ÿ ====================
        
        const InfoPanel = {
            panel: null,
            timer: null,
            
            init() {
                this.panel = document.getElementById('info-panel');
            },
            
            show(planet) {
                clearTimeout(this.timer);
                
                document.getElementById('info-title').textContent = planet.emoji + ' ' + planet.name;
                document.getElementById('info-distance').textContent = 'ğŸ“ ' + planet.distance;
                document.getElementById('info-temp').textContent = 'ğŸŒ¡ï¸ ' + planet.temp;
                document.getElementById('info-fun').textContent = planet.fun;
                
                this.panel.style.display = 'block';
                this.panel.style.animation = 'none';
                this.panel.offsetHeight;
                this.panel.style.animation = 'slideIn 0.3s ease-out';
                
                this.timer = setTimeout(() => {
                    this.hide();
                }, 8000);
            },
            
            hide() {
                this.panel.style.display = 'none';
            }
        };
        
        // ==================== ç‰©ç†å¼•æ“ ====================
        
        const PhysicsEngine = {
            update() {
                GameState.planets.forEach(planet => {
                    if (planet.isSnapped && !GameState.isComplete) {
                        const orbitRadius = ORBIT_CONFIG.baseRadius + planet.orbitIndex * ORBIT_CONFIG.spacing;
                        
                        // å¼€æ™®å‹’ç¬¬ä¸‰å®šå¾‹ï¼šv âˆ 1/âˆšr
                        // è·ç¦»å¤ªé˜³è¶Šè¿‘ï¼Œè§’é€Ÿåº¦è¶Šå¿«
                        const baseSpeed = 0.02;
                        const angularSpeed = (baseSpeed / Math.sqrt(planet.orbitIndex + 1)) * GameState.speedMultiplier;
                        
                        if (!planet.angle) {
                            planet.angle = Math.atan2(
                                planet.y - ORBIT_CONFIG.centerY,
                                planet.x - ORBIT_CONFIG.centerX
                            );
                        }
                        
                        planet.angle += angularSpeed;
                        
                        planet.x = ORBIT_CONFIG.centerX + Math.cos(planet.angle) * orbitRadius;
                        planet.y = ORBIT_CONFIG.centerY + Math.sin(planet.angle) * orbitRadius;
                        
                        // è®°å½•è½¨è¿¹
                        TrailRenderer.addPoint(planet);
                    }
                });
            }
        };
        
        // ==================== è½¨è¿¹æ¸²æŸ“ç³»ç»Ÿ ====================
        
        const TrailRenderer = {
            trails: new Map(),
            maxLength: 80,
            
            addPoint(planet) {
                if (!this.trails.has(planet)) {
                    this.trails.set(planet, []);
                }
                
                const trail = this.trails.get(planet);
                trail.push({ x: planet.x, y: planet.y });
                
                if (trail.length > this.maxLength) {
                    trail.shift();
                }
            },
            
            clear() {
                this.trails.clear();
            },
            
            render(ctx) {
                this.trails.forEach((trail, planet) => {
                    if (trail.length < 2) return;
                    
                    ctx.beginPath();
                    ctx.moveTo(trail[0].x, trail[0].y);
                    
                    for (let i = 1; i < trail.length; i++) {
                        ctx.lineTo(trail[i].x, trail[i].y);
                    }
                    
                    // æ¸å˜è½¨è¿¹
                    const gradient = ctx.createLinearGradient(
                        trail[0].x, trail[0].y,
                        trail[trail.length - 1].x, trail[trail.length - 1].y
                    );
                    gradient.addColorStop(0, this.hexToRgba(planet.color, 0));
                    gradient.addColorStop(1, this.hexToRgba(planet.color, 0.6));
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                });
            },
            
            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        };
        
        // ==================== éŸ³æ•ˆå¼•æ“ ====================
        
        const AudioEngine = {
            audioContext: null,
            
            init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            },
            
            playSnap() {
                if (!this.audioContext) return;
                
                const ctx = this.audioContext;
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, ctx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                
                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.3);
            },
            
            playComplete() {
                if (!this.audioContext) return;
                
                const ctx = this.audioContext;
                [523, 659, 784, 1047].forEach((freq, index) => {
                    setTimeout(() => {
                        const oscillator = ctx.createOscillator();
                        const gainNode = ctx.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(ctx.destination);
                        
                        oscillator.frequency.value = freq;
                        oscillator.type = 'sine';
                        
                        gainNode.gain.setValueAtTime(0, ctx.currentTime);
                        gainNode.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
                        
                        oscillator.start(ctx.currentTime);
                        oscillator.stop(ctx.currentTime + 0.5);
                    }, index * 120);
                });
            },
            
            playHover() {
                if (!this.audioContext) return;
                
                const ctx = this.audioContext;
                const oscillator = ctx.createOscillator();
                const gainNode = ctx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(ctx.destination);
                
                oscillator.frequency.value = 400;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, ctx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.1, ctx.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
                
                oscillator.start(ctx.currentTime);
                oscillator.stop(ctx.currentTime + 0.15);
            }
        };
        
        // ==================== æ ¸å¿ƒæ¸¸æˆç±» ====================
        
        const Game = {
            init() {
                GameState.canvas = document.getElementById('game-canvas');
                GameState.ctx = GameState.canvas.getContext('2d');
                
                // åˆå§‹åŒ–ç³»ç»Ÿ
                HintSystem.init();
                InfoPanel.init();
                
                // ç»‘å®šéŸ³é¢‘åˆå§‹åŒ–
                document.addEventListener('click', () => {
                    if (!AudioEngine.audioContext) {
                        AudioEngine.init();
                    }
                }, { once: true });
                
                // å“åº”çª—å£
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // åˆå§‹åŒ–è¡Œæ˜Ÿ
                this.initPlanets();
                
                // ç»‘å®šäº‹ä»¶
                this.bindEvents();
                
                // åˆ›å»ºæ˜Ÿæ˜Ÿ
                this.createStars();
                
                // éšè—åŠ è½½ç•Œé¢
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
                
                // å¼€å§‹æ¸²æŸ“
                this.startRenderLoop();
            },
            
            resizeCanvas() {
                const canvas = GameState.canvas;
                GameState.width = window.innerWidth;
                GameState.height = window.innerHeight;
                
                canvas.width = GameState.width;
                canvas.height = GameState.height;
                
                ORBIT_CONFIG.centerX = GameState.width / 2;
                ORBIT_CONFIG.centerY = GameState.height * 0.35;
                
                GameState.planetAreaY = GameState.height * 0.75;
                GameState.planetSpacing = GameState.width / (PLANET_DATA.length + 1);
                
                this.initPlanets();
            },
            
            initPlanets() {
                GameState.planets = PLANET_DATA.map((data, index) => {
                    return {
                        ...data,
                        x: GameState.planetSpacing * (index + 1),
                        y: GameState.planetAreaY,
                        originalX: GameState.planetSpacing * (index + 1),
                        originalY: GameState.planetAreaY,
                        isDragging: false,
                        isSnapped: false,
                        snappedOrbitIndex: null,
                        angle: 0
                    };
                });
                
                GameState.completedOrbits = [];
                GameState.isComplete = false;
                GameState.startTime = null;
                TrailRenderer.clear();
            },
            
            bindEvents() {
                const canvas = GameState.canvas;
                
                canvas.addEventListener('mousedown', (e) => this.handleStart(e.clientX, e.clientY));
                canvas.addEventListener('mousemove', (e) => this.handleMove(e.clientX, e.clientY));
                canvas.addEventListener('mouseup', () => this.handleEnd());
                canvas.addEventListener('mouseleave', () => this.handleEnd());
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleStart(touch.clientX, touch.clientY);
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleMove(touch.clientX, touch.clientY);
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleEnd();
                });
            },
            
            handleStart(x, y) {
                if (GameState.isComplete) return;
                
                for (let i = GameState.planets.length - 1; i >= 0; i--) {
                    const planet = GameState.planets[i];
                    
                    if (planet.isSnapped && !GameState.experimentMode) continue;
                    
                    const distance = Math.sqrt((x - planet.x) ** 2 + (y - planet.y) ** 2);
                    
                    if (distance <= planet.radius) {
                        GameState.draggingPlanet = planet;
                        planet.isDragging = true;
                        
                        GameState.planets.splice(i, 1);
                        GameState.planets.push(planet);
                        
                        // æ’­æ”¾æ‚¬åœéŸ³æ•ˆ
                        AudioEngine.playHover();
                        
                        if (!GameState.startTime) {
                            GameState.startTime = Date.now();
                        }
                        
                        HintSystem.setState('dragging');
                        break;
                    }
                }
            },
            
            handleMove(x, y) {
                if (!GameState.draggingPlanet) return;
                
                const planet = GameState.draggingPlanet;
                planet.x = x;
                planet.y = y;
                
                // æ£€æŸ¥æ˜¯å¦é è¿‘è½¨é“
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                const currentDistance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                const targetRadius = ORBIT_CONFIG.baseRadius + planet.orbitIndex * ORBIT_CONFIG.spacing;
                
                if (Math.abs(currentDistance - targetRadius) <= 40) {
                    HintSystem.setState('near_orbit');
                } else {
                    HintSystem.setState('dragging');
                }
            },
            
            handleEnd() {
                if (!GameState.draggingPlanet) return;
                
                const planet = GameState.draggingPlanet;
                GameState.currentAttempt++;
                
                if (GameState.experimentMode) {
                    // å®éªŒæ¨¡å¼ï¼šå¸é™„åˆ°æœ€è¿‘è½¨é“
                    const closestOrbit = this.findClosestOrbit(planet);
                    if (closestOrbit !== null) {
                        this.snapToOrbit(planet, closestOrbit, true);
                    } else {
                        this.reboundToOriginal(planet);
                    }
                } else {
                    // æ¸¸æˆæ¨¡å¼ï¼šåªèƒ½å¸é™„åˆ°æ­£ç¡®è½¨é“
                    const correctOrbit = this.checkSnap(planet);
                    if (correctOrbit !== null) {
                        this.snapToOrbit(planet, correctOrbit);
                    } else {
                        HintSystem.setState('wrong_orbit');
                        this.reboundToOriginal(planet);
                    }
                }
                
                planet.isDragging = false;
                GameState.draggingPlanet = null;
            },
            
            findClosestOrbit(planet) {
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                const currentDistance = Math.sqrt(
                    (planet.x - centerX) ** 2 + (planet.y - centerY) ** 2
                );
                
                let closestIndex = null;
                let minDiff = Infinity;
                
                for (let i = 0; i < ORBIT_CONFIG.count; i++) {
                    const targetRadius = ORBIT_CONFIG.baseRadius + i * ORBIT_CONFIG.spacing;
                    const diff = Math.abs(currentDistance - targetRadius);
                    
                    if (diff < minDiff && diff <= 40) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }
                
                return closestIndex;
            },
            
            checkSnap(planet) {
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                
                const targetRadius = ORBIT_CONFIG.baseRadius + planet.orbitIndex * ORBIT_CONFIG.spacing;
                const currentDistance = Math.sqrt(
                    (planet.x - centerX) ** 2 + (planet.y - centerY) ** 2
                );
                
                const SNAP_THRESHOLD = 40;
                
                if (Math.abs(currentDistance - targetRadius) <= SNAP_THRESHOLD) {
                    if (!GameState.completedOrbits.includes(planet.orbitIndex)) {
                        return planet.orbitIndex;
                    }
                }
                
                return null;
            },
            
            snapToOrbit(planet, orbitIndex, isExperiment = false) {
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                const radius = ORBIT_CONFIG.baseRadius + orbitIndex * ORBIT_CONFIG.spacing;
                
                const angle = Math.atan2(planet.y - centerY, planet.x - centerX);
                const snapX = centerX + Math.cos(angle) * radius;
                const snapY = centerY + Math.sin(angle) * radius;
                
                planet.x = snapX;
                planet.y = snapY;
                planet.isSnapped = true;
                planet.orbitIndex = orbitIndex;
                planet.angle = angle;
                
                if (!isExperiment) {
                    planet.snappedOrbitIndex = orbitIndex;
                    GameState.completedOrbits.push(orbitIndex);
                    HintSystem.setState('snapped');
                    InfoPanel.show(planet);
                    
                    this.checkComplete();
                } else {
                    InfoPanel.show(planet);
                }
                
                AudioEngine.playSnap();
            },
            
            reboundToOriginal(planet) {
                planet.x = planet.originalX;
                planet.y = planet.originalY;
            },
            
            checkComplete() {
                if (GameState.completedOrbits.length === PLANET_DATA.length) {
                    GameState.isComplete = true;
                    
                    const completionTime = ((Date.now() - GameState.startTime) / 1000).toFixed(1);
                    GameState.attempts = GameState.currentAttempt;
                    
                    document.getElementById('completion-time').textContent = completionTime;
                    document.getElementById('attempt-count').textContent = GameState.attempts;
                    
                    setTimeout(() => {
                        this.showReward();
                    }, 800);
                }
            },
            
            showReward() {
                AudioEngine.playComplete();
                
                const overlay = document.getElementById('reward-overlay');
                const rocket = document.getElementById('rocket');
                
                overlay.style.display = 'flex';
                
                rocket.style.left = '50%';
                rocket.style.bottom = '0';
                rocket.style.transform = 'translateX(-50%)';
                rocket.style.opacity = '1';
                rocket.style.transition = 'all 4s ease-out';
                
                requestAnimationFrame(() => {
                    rocket.style.bottom = '100%';
                    rocket.style.opacity = '0';
                });
                
                HintSystem.setState('complete');
            },
            
            restart() {
                document.getElementById('reward-overlay').style.display = 'none';
                
                const rocket = document.getElementById('rocket');
                rocket.style.transition = 'none';
                rocket.style.bottom = '0';
                rocket.style.opacity = '0';
                
                this.initPlanets();
                HintSystem.setState('welcome');
                GameState.currentAttempt = 0;
            },
            
            toggleExperimentMode() {
                GameState.experimentMode = !GameState.experimentMode;
                
                const btn = document.querySelector('.control-btn:nth-child(1)');
                btn.classList.toggle('active', GameState.experimentMode);
                
                if (GameState.experimentMode) {
                    HintSystem.setState('experiment');
                } else {
                    HintSystem.setState('welcome');
                    this.resetOrbits();
                }
            },
            
            toggleSlowMotion() {
                GameState.slowMotion = !GameState.slowMotion;
                GameState.speedMultiplier = GameState.slowMotion ? 0.3 : 1.0;
                
                const btn = document.querySelector('.control-btn:nth-child(2)');
                btn.classList.toggle('active', GameState.slowMotion);
                
                document.getElementById('speed-indicator').textContent = 
                    'âš¡ é€Ÿåº¦: ' + GameState.speedMultiplier.toFixed(1) + 'x';
            },
            
            resetOrbits() {
                GameState.planets.forEach(planet => {
                    planet.isSnapped = false;
                    planet.orbitIndex = PLANET_DATA.find(p => p.name === planet.name).orbitIndex;
                    planet.x = planet.originalX;
                    planet.y = planet.originalY;
                    planet.angle = 0;
                });
                
                GameState.completedOrbits = [];
                GameState.isComplete = false;
                TrailRenderer.clear();
                HintSystem.setState('welcome');
            },
            
            closeInfoPanel() {
                InfoPanel.hide();
            },
            
            createStars() {
                const container = document.getElementById('game-container');
                
                const existingStars = container.querySelectorAll('.star');
                existingStars.forEach(star => star.remove());
                
                for (let i = 0; i < 60; i++) {
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    star.style.left = Math.random() * 100 + '%';
                    star.style.top = Math.random() * 70 + '%';
                    
                    const size = Math.random() * 3 + 1;
                    star.style.width = size + 'px';
                    star.style.height = size + 'px';
                    
                    star.style.animationDelay = Math.random() * 3 + 's';
                    star.style.animationDuration = (Math.random() * 2 + 1) + 's';
                    
                    container.appendChild(star);
                }
            },
            
            startRenderLoop() {
                const render = () => {
                    PhysicsEngine.update();
                    this.render();
                    requestAnimationFrame(render);
                };
                render();
            },
            
            render() {
                const ctx = GameState.ctx;
                const width = GameState.width;
                const height = GameState.height;
                
                ctx.clearRect(0, 0, width, height);
                
                this.renderOrbits(ctx);
                this.renderSun(ctx);
                TrailRenderer.render(ctx);
                this.renderPlanets(ctx);
                
                if (GameState.draggingPlanet) {
                    this.renderDragHint(ctx);
                }
            },
            
            renderOrbits(ctx) {
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                
                for (let i = 0; i < ORBIT_CONFIG.count; i++) {
                    const radius = ORBIT_CONFIG.baseRadius + i * ORBIT_CONFIG.spacing;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    if (GameState.completedOrbits.includes(i)) {
                        ctx.setLineDash([]);
                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
                        ctx.lineWidth = 3;
                    } else if (GameState.experimentMode) {
                        ctx.setLineDash([5, 5]);
                        ctx.strokeStyle = 'rgba(150, 150, 255, 0.4)';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.setLineDash([8, 8]);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                        ctx.lineWidth = 2;
                    }
                    
                    ctx.stroke();
                }
                
                ctx.setLineDash([]);
                
                // ç»˜åˆ¶è½¨é“æ ‡ç­¾ï¼ˆå®éªŒæ¨¡å¼ä¸‹ï¼‰
                if (GameState.experimentMode) {
                    const labels = ['æœ€å†…', '', 'ä¸­', '', 'æœ€å¤–'];
                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.textAlign = 'center';
                    
                    for (let i = 0; i < ORBIT_CONFIG.count; i++) {
                        if (labels[i]) {
                            const radius = ORBIT_CONFIG.baseRadius + i * ORBIT_CONFIG.spacing;
                            ctx.fillText(labels[i], centerX, centerY - radius - 5);
                        }
                    }
                }
            },
            
            renderSun(ctx) {
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                const radius = 45;
                
                // å¤–å‘å…‰
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, radius * 0.5,
                    centerX, centerY, radius * 2.5
                );
                gradient.addColorStop(0, 'rgba(255, 200, 50, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 200, 50, 0)');
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 2.5, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // å¤ªé˜³æœ¬ä½“
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = '#ffcc00';
                ctx.fill();
                
                // å¤ªé˜³è¡¨é¢çº¹ç†
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('â˜€ï¸', centerX, centerY);
            },
            
            renderPlanets(ctx) {
                GameState.planets.forEach(planet => {
                    if (planet.isDragging) {
                        ctx.beginPath();
                        ctx.arc(planet.x + 8, planet.y + 8, planet.radius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fill();
                    }
                    
                    ctx.beginPath();
                    ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
                    
                    const gradient = ctx.createRadialGradient(
                        planet.x - planet.radius * 0.3,
                        planet.y - planet.radius * 0.3,
                        0,
                        planet.x, planet.y, planet.radius
                    );
                    gradient.addColorStop(0, this.lightenColor(planet.color, 40));
                    gradient.addColorStop(1, planet.color);
                    
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.strokeStyle = planet.isSnapped ? '#00ff00' : 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = planet.isSnapped ? 3 : 2;
                    ctx.stroke();
                    
                    ctx.font = 'bold 13px Arial';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(planet.name, planet.x, planet.y);
                });
            },
            
            renderDragHint(ctx) {
                const planet = GameState.draggingPlanet;
                const centerX = ORBIT_CONFIG.centerX;
                const centerY = ORBIT_CONFIG.centerY;
                
                const currentDistance = Math.sqrt(
                    (planet.x - centerX) ** 2 + (planet.y - centerY) ** 2
                );
                
                let targetOrbitIndex;
                if (GameState.experimentMode) {
                    targetOrbitIndex = this.findClosestOrbit(planet);
                } else {
                    targetOrbitIndex = planet.orbitIndex;
                }
                
                if (targetOrbitIndex !== null) {
                    const targetRadius = ORBIT_CONFIG.baseRadius + targetOrbitIndex * ORBIT_CONFIG.spacing;
                    const isInRange = Math.abs(currentDistance - targetRadius) <= 40;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(planet.x, planet.y);
                    ctx.strokeStyle = isInRange ? 'rgba(100, 255, 100, 0.5)' : 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    if (isInRange && !GameState.completedOrbits.includes(targetOrbitIndex)) {
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, targetRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(100, 255, 100, 0.8)';
                        ctx.lineWidth = 4;
                        ctx.stroke();
                    }
                }
            },
            
            lightenColor(color, percent) {
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = Math.min(255, (num >> 16) + amt);
                const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
                const B = Math.min(255, (num & 0x0000FF) + amt);
                return `rgb(${R}, ${G}, ${B})`;
            }
        };
        
        const game = Game;
        
        window.addEventListener('load', () => {
            game.init();
        });
    </script>
</body>
</html>
